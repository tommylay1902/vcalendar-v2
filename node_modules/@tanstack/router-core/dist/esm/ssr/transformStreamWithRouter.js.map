{"version":3,"file":"transformStreamWithRouter.js","sources":["../../../src/ssr/transformStreamWithRouter.ts"],"sourcesContent":["import { ReadableStream } from 'node:stream/web'\nimport { Readable } from 'node:stream'\nimport { createControlledPromise } from '../utils'\nimport type { AnyRouter } from '../router'\n\nexport function transformReadableStreamWithRouter(\n  router: AnyRouter,\n  routerStream: ReadableStream,\n) {\n  return transformStreamWithRouter(router, routerStream)\n}\n\nexport function transformPipeableStreamWithRouter(\n  router: AnyRouter,\n  routerStream: Readable,\n) {\n  return Readable.fromWeb(\n    transformStreamWithRouter(router, Readable.toWeb(routerStream)),\n  )\n}\n\nexport const TSR_SCRIPT_BARRIER_ID = '$tsr-stream-barrier'\n\n// regex pattern for matching closing body and html tags\nconst patternBodyEnd = /(<\\/body>)/\nconst patternHtmlEnd = /(<\\/html>)/\n// regex pattern for matching closing tags\nconst patternClosingTag = /(<\\/[a-zA-Z][\\w:.-]*?>)/g\n\ntype ReadablePassthrough = {\n  stream: ReadableStream\n  write: (chunk: unknown) => void\n  end: (chunk?: string) => void\n  destroy: (error: unknown) => void\n  destroyed: boolean\n}\n\nfunction createPassthrough(onCancel: () => void) {\n  let controller: ReadableStreamDefaultController<any>\n  const encoder = new TextEncoder()\n  const stream = new ReadableStream({\n    start(c) {\n      controller = c\n    },\n    cancel() {\n      res.destroyed = true\n      onCancel()\n    },\n  })\n\n  const res: ReadablePassthrough = {\n    stream,\n    write: (chunk) => {\n      // Don't write to destroyed stream\n      if (res.destroyed) return\n      if (typeof chunk === 'string') {\n        controller.enqueue(encoder.encode(chunk))\n      } else {\n        controller.enqueue(chunk)\n      }\n    },\n    end: (chunk) => {\n      // Don't end already destroyed stream\n      if (res.destroyed) return\n      if (chunk) {\n        res.write(chunk)\n      }\n      res.destroyed = true\n      controller.close()\n    },\n    destroy: (error) => {\n      // Don't destroy already destroyed stream\n      if (res.destroyed) return\n      res.destroyed = true\n      controller.error(error)\n    },\n    destroyed: false,\n  }\n\n  return res\n}\n\nasync function readStream(\n  stream: ReadableStream,\n  opts: {\n    onData?: (chunk: ReadableStreamReadValueResult<any>) => void\n    onEnd?: () => void\n    onError?: (error: unknown) => void\n  },\n) {\n  const reader = stream.getReader()\n  try {\n    let chunk\n    while (!(chunk = await reader.read()).done) {\n      opts.onData?.(chunk)\n    }\n    opts.onEnd?.()\n  } catch (error) {\n    opts.onError?.(error)\n  } finally {\n    reader.releaseLock()\n  }\n}\n\nexport function transformStreamWithRouter(\n  router: AnyRouter,\n  appStream: ReadableStream,\n  opts?: {\n    timeoutMs?: number\n  },\n) {\n  let stopListeningToInjectedHtml: (() => void) | undefined = undefined\n  let timeoutHandle: NodeJS.Timeout\n  let cleanedUp = false\n\n  function cleanup() {\n    if (cleanedUp) return\n    cleanedUp = true\n    if (stopListeningToInjectedHtml) {\n      stopListeningToInjectedHtml()\n      stopListeningToInjectedHtml = undefined\n    }\n    clearTimeout(timeoutHandle)\n    router.serverSsr?.cleanup()\n  }\n\n  const finalPassThrough = createPassthrough(cleanup)\n  const textDecoder = new TextDecoder()\n\n  let isAppRendering = true\n  let routerStreamBuffer = ''\n  let pendingClosingTags = ''\n  let streamBarrierLifted = false\n  let leftover = ''\n  let leftoverHtml = ''\n\n  function getBufferedRouterStream() {\n    const html = routerStreamBuffer\n    routerStreamBuffer = ''\n    return html\n  }\n\n  function decodeChunk(chunk: unknown): string {\n    if (chunk instanceof Uint8Array) {\n      return textDecoder.decode(chunk, { stream: true })\n    }\n    return String(chunk)\n  }\n\n  const injectedHtmlDonePromise = createControlledPromise<void>()\n\n  let processingCount = 0\n\n  // Process any already-injected HTML\n  handleInjectedHtml()\n\n  // Listen for any new injected HTML\n  stopListeningToInjectedHtml = router.subscribe(\n    'onInjectedHtml',\n    handleInjectedHtml,\n  )\n\n  function handleInjectedHtml() {\n    // Don't process if already cleaned up\n    if (cleanedUp) return\n\n    router.serverSsr!.injectedHtml.forEach((promise) => {\n      processingCount++\n\n      promise\n        .then((html) => {\n          // Don't write to destroyed stream or after cleanup\n          if (cleanedUp || finalPassThrough.destroyed) {\n            return\n          }\n          if (isAppRendering) {\n            routerStreamBuffer += html\n          } else {\n            finalPassThrough.write(html)\n          }\n        })\n        .catch((err) => {\n          injectedHtmlDonePromise.reject(err)\n        })\n        .finally(() => {\n          processingCount--\n\n          if (!isAppRendering && processingCount === 0) {\n            injectedHtmlDonePromise.resolve()\n          }\n        })\n    })\n    router.serverSsr!.injectedHtml = []\n  }\n\n  injectedHtmlDonePromise\n    .then(() => {\n      // Don't process if already cleaned up or destroyed\n      if (cleanedUp || finalPassThrough.destroyed) {\n        return\n      }\n\n      clearTimeout(timeoutHandle)\n      const finalHtml =\n        leftover + leftoverHtml + getBufferedRouterStream() + pendingClosingTags\n\n      leftover = ''\n      leftoverHtml = ''\n      pendingClosingTags = ''\n\n      finalPassThrough.end(finalHtml)\n    })\n    .catch((err) => {\n      // Don't process if already cleaned up\n      if (cleanedUp || finalPassThrough.destroyed) {\n        return\n      }\n\n      console.error('Error reading routerStream:', err)\n      finalPassThrough.destroy(err)\n    })\n    .finally(cleanup)\n\n  // Transform the appStream\n  readStream(appStream, {\n    onData: (chunk) => {\n      // Don't process if already cleaned up\n      if (cleanedUp || finalPassThrough.destroyed) {\n        return\n      }\n\n      const text = decodeChunk(chunk.value)\n      const chunkString = leftover + text\n      const bodyEndMatch = chunkString.match(patternBodyEnd)\n      const htmlEndMatch = chunkString.match(patternHtmlEnd)\n\n      if (!streamBarrierLifted) {\n        const streamBarrierIdIncluded = chunkString.includes(\n          TSR_SCRIPT_BARRIER_ID,\n        )\n        if (streamBarrierIdIncluded) {\n          streamBarrierLifted = true\n          router.serverSsr!.liftScriptBarrier()\n        }\n      }\n\n      // If either the body end or html end is in the chunk,\n      // We need to get all of our data in asap\n      if (\n        bodyEndMatch &&\n        htmlEndMatch &&\n        bodyEndMatch.index! < htmlEndMatch.index!\n      ) {\n        const bodyEndIndex = bodyEndMatch.index!\n        pendingClosingTags = chunkString.slice(bodyEndIndex)\n\n        finalPassThrough.write(\n          chunkString.slice(0, bodyEndIndex) +\n            getBufferedRouterStream() +\n            leftoverHtml,\n        )\n\n        leftover = ''\n        leftoverHtml = ''\n        return\n      }\n\n      let result: RegExpExecArray | null\n      let lastIndex = 0\n      // Reset regex lastIndex since it's global and stateful across exec() calls\n      patternClosingTag.lastIndex = 0\n      while ((result = patternClosingTag.exec(chunkString)) !== null) {\n        lastIndex = result.index + result[0].length\n      }\n\n      if (lastIndex > 0) {\n        const processed =\n          chunkString.slice(0, lastIndex) +\n          getBufferedRouterStream() +\n          leftoverHtml\n\n        finalPassThrough.write(processed)\n        leftover = chunkString.slice(lastIndex)\n        leftoverHtml = ''\n      } else {\n        leftover = chunkString\n        leftoverHtml += getBufferedRouterStream()\n      }\n    },\n    onEnd: () => {\n      // Don't process if stream was already destroyed/cancelled or cleaned up\n      if (cleanedUp || finalPassThrough.destroyed) {\n        return\n      }\n\n      // Mark the app as done rendering\n      isAppRendering = false\n      router.serverSsr!.setRenderFinished()\n\n      // If there are no pending promises, resolve the injectedHtmlDonePromise\n      if (processingCount === 0) {\n        injectedHtmlDonePromise.resolve()\n      } else {\n        const timeoutMs = opts?.timeoutMs ?? 60000\n        timeoutHandle = setTimeout(() => {\n          injectedHtmlDonePromise.reject(\n            new Error('Injected HTML timeout after app render finished'),\n          )\n        }, timeoutMs)\n      }\n    },\n    onError: (error) => {\n      // Don't process if already cleaned up\n      if (cleanedUp) {\n        return\n      }\n\n      console.error('Error reading appStream:', error)\n      isAppRendering = false\n      router.serverSsr!.setRenderFinished()\n      // Clear timeout to prevent it from firing after error\n      clearTimeout(timeoutHandle)\n      // Clear string buffers to prevent memory leaks\n      leftover = ''\n      leftoverHtml = ''\n      routerStreamBuffer = ''\n      pendingClosingTags = ''\n      finalPassThrough.destroy(error)\n      injectedHtmlDonePromise.reject(error)\n    },\n  })\n\n  return finalPassThrough.stream\n}\n"],"names":[],"mappings":";;;AAKO,SAAS,kCACd,QACA,cACA;AACA,SAAO,0BAA0B,QAAQ,YAAY;AACvD;AAEO,SAAS,kCACd,QACA,cACA;AACA,SAAO,SAAS;AAAA,IACd,0BAA0B,QAAQ,SAAS,MAAM,YAAY,CAAC;AAAA,EAAA;AAElE;AAEO,MAAM,wBAAwB;AAGrC,MAAM,iBAAiB;AACvB,MAAM,iBAAiB;AAEvB,MAAM,oBAAoB;AAU1B,SAAS,kBAAkB,UAAsB;AAC/C,MAAI;AACJ,QAAM,UAAU,IAAI,YAAA;AACpB,QAAM,SAAS,IAAI,eAAe;AAAA,IAChC,MAAM,GAAG;AACP,mBAAa;AAAA,IACf;AAAA,IACA,SAAS;AACP,UAAI,YAAY;AAChB,eAAA;AAAA,IACF;AAAA,EAAA,CACD;AAED,QAAM,MAA2B;AAAA,IAC/B;AAAA,IACA,OAAO,CAAC,UAAU;AAEhB,UAAI,IAAI,UAAW;AACnB,UAAI,OAAO,UAAU,UAAU;AAC7B,mBAAW,QAAQ,QAAQ,OAAO,KAAK,CAAC;AAAA,MAC1C,OAAO;AACL,mBAAW,QAAQ,KAAK;AAAA,MAC1B;AAAA,IACF;AAAA,IACA,KAAK,CAAC,UAAU;AAEd,UAAI,IAAI,UAAW;AACnB,UAAI,OAAO;AACT,YAAI,MAAM,KAAK;AAAA,MACjB;AACA,UAAI,YAAY;AAChB,iBAAW,MAAA;AAAA,IACb;AAAA,IACA,SAAS,CAAC,UAAU;AAElB,UAAI,IAAI,UAAW;AACnB,UAAI,YAAY;AAChB,iBAAW,MAAM,KAAK;AAAA,IACxB;AAAA,IACA,WAAW;AAAA,EAAA;AAGb,SAAO;AACT;AAEA,eAAe,WACb,QACA,MAKA;AACA,QAAM,SAAS,OAAO,UAAA;AACtB,MAAI;AACF,QAAI;AACJ,WAAO,EAAE,QAAQ,MAAM,OAAO,KAAA,GAAQ,MAAM;AAC1C,WAAK,SAAS,KAAK;AAAA,IACrB;AACA,SAAK,QAAA;AAAA,EACP,SAAS,OAAO;AACd,SAAK,UAAU,KAAK;AAAA,EACtB,UAAA;AACE,WAAO,YAAA;AAAA,EACT;AACF;AAEO,SAAS,0BACd,QACA,WACA,MAGA;AACA,MAAI,8BAAwD;AAC5D,MAAI;AACJ,MAAI,YAAY;AAEhB,WAAS,UAAU;AACjB,QAAI,UAAW;AACf,gBAAY;AACZ,QAAI,6BAA6B;AAC/B,kCAAA;AACA,oCAA8B;AAAA,IAChC;AACA,iBAAa,aAAa;AAC1B,WAAO,WAAW,QAAA;AAAA,EACpB;AAEA,QAAM,mBAAmB,kBAAkB,OAAO;AAClD,QAAM,cAAc,IAAI,YAAA;AAExB,MAAI,iBAAiB;AACrB,MAAI,qBAAqB;AACzB,MAAI,qBAAqB;AACzB,MAAI,sBAAsB;AAC1B,MAAI,WAAW;AACf,MAAI,eAAe;AAEnB,WAAS,0BAA0B;AACjC,UAAM,OAAO;AACb,yBAAqB;AACrB,WAAO;AAAA,EACT;AAEA,WAAS,YAAY,OAAwB;AAC3C,QAAI,iBAAiB,YAAY;AAC/B,aAAO,YAAY,OAAO,OAAO,EAAE,QAAQ,MAAM;AAAA,IACnD;AACA,WAAO,OAAO,KAAK;AAAA,EACrB;AAEA,QAAM,0BAA0B,wBAAA;AAEhC,MAAI,kBAAkB;AAGtB,qBAAA;AAGA,gCAA8B,OAAO;AAAA,IACnC;AAAA,IACA;AAAA,EAAA;AAGF,WAAS,qBAAqB;AAE5B,QAAI,UAAW;AAEf,WAAO,UAAW,aAAa,QAAQ,CAAC,YAAY;AAClD;AAEA,cACG,KAAK,CAAC,SAAS;AAEd,YAAI,aAAa,iBAAiB,WAAW;AAC3C;AAAA,QACF;AACA,YAAI,gBAAgB;AAClB,gCAAsB;AAAA,QACxB,OAAO;AACL,2BAAiB,MAAM,IAAI;AAAA,QAC7B;AAAA,MACF,CAAC,EACA,MAAM,CAAC,QAAQ;AACd,gCAAwB,OAAO,GAAG;AAAA,MACpC,CAAC,EACA,QAAQ,MAAM;AACb;AAEA,YAAI,CAAC,kBAAkB,oBAAoB,GAAG;AAC5C,kCAAwB,QAAA;AAAA,QAC1B;AAAA,MACF,CAAC;AAAA,IACL,CAAC;AACD,WAAO,UAAW,eAAe,CAAA;AAAA,EACnC;AAEA,0BACG,KAAK,MAAM;AAEV,QAAI,aAAa,iBAAiB,WAAW;AAC3C;AAAA,IACF;AAEA,iBAAa,aAAa;AAC1B,UAAM,YACJ,WAAW,eAAe,wBAAA,IAA4B;AAExD,eAAW;AACX,mBAAe;AACf,yBAAqB;AAErB,qBAAiB,IAAI,SAAS;AAAA,EAChC,CAAC,EACA,MAAM,CAAC,QAAQ;AAEd,QAAI,aAAa,iBAAiB,WAAW;AAC3C;AAAA,IACF;AAEA,YAAQ,MAAM,+BAA+B,GAAG;AAChD,qBAAiB,QAAQ,GAAG;AAAA,EAC9B,CAAC,EACA,QAAQ,OAAO;AAGlB,aAAW,WAAW;AAAA,IACpB,QAAQ,CAAC,UAAU;AAEjB,UAAI,aAAa,iBAAiB,WAAW;AAC3C;AAAA,MACF;AAEA,YAAM,OAAO,YAAY,MAAM,KAAK;AACpC,YAAM,cAAc,WAAW;AAC/B,YAAM,eAAe,YAAY,MAAM,cAAc;AACrD,YAAM,eAAe,YAAY,MAAM,cAAc;AAErD,UAAI,CAAC,qBAAqB;AACxB,cAAM,0BAA0B,YAAY;AAAA,UAC1C;AAAA,QAAA;AAEF,YAAI,yBAAyB;AAC3B,gCAAsB;AACtB,iBAAO,UAAW,kBAAA;AAAA,QACpB;AAAA,MACF;AAIA,UACE,gBACA,gBACA,aAAa,QAAS,aAAa,OACnC;AACA,cAAM,eAAe,aAAa;AAClC,6BAAqB,YAAY,MAAM,YAAY;AAEnD,yBAAiB;AAAA,UACf,YAAY,MAAM,GAAG,YAAY,IAC/B,4BACA;AAAA,QAAA;AAGJ,mBAAW;AACX,uBAAe;AACf;AAAA,MACF;AAEA,UAAI;AACJ,UAAI,YAAY;AAEhB,wBAAkB,YAAY;AAC9B,cAAQ,SAAS,kBAAkB,KAAK,WAAW,OAAO,MAAM;AAC9D,oBAAY,OAAO,QAAQ,OAAO,CAAC,EAAE;AAAA,MACvC;AAEA,UAAI,YAAY,GAAG;AACjB,cAAM,YACJ,YAAY,MAAM,GAAG,SAAS,IAC9B,4BACA;AAEF,yBAAiB,MAAM,SAAS;AAChC,mBAAW,YAAY,MAAM,SAAS;AACtC,uBAAe;AAAA,MACjB,OAAO;AACL,mBAAW;AACX,wBAAgB,wBAAA;AAAA,MAClB;AAAA,IACF;AAAA,IACA,OAAO,MAAM;AAEX,UAAI,aAAa,iBAAiB,WAAW;AAC3C;AAAA,MACF;AAGA,uBAAiB;AACjB,aAAO,UAAW,kBAAA;AAGlB,UAAI,oBAAoB,GAAG;AACzB,gCAAwB,QAAA;AAAA,MAC1B,OAAO;AACL,cAAM,YAAY,MAAM,aAAa;AACrC,wBAAgB,WAAW,MAAM;AAC/B,kCAAwB;AAAA,YACtB,IAAI,MAAM,iDAAiD;AAAA,UAAA;AAAA,QAE/D,GAAG,SAAS;AAAA,MACd;AAAA,IACF;AAAA,IACA,SAAS,CAAC,UAAU;AAElB,UAAI,WAAW;AACb;AAAA,MACF;AAEA,cAAQ,MAAM,4BAA4B,KAAK;AAC/C,uBAAiB;AACjB,aAAO,UAAW,kBAAA;AAElB,mBAAa,aAAa;AAE1B,iBAAW;AACX,qBAAe;AACf,2BAAqB;AACrB,2BAAqB;AACrB,uBAAiB,QAAQ,KAAK;AAC9B,8BAAwB,OAAO,KAAK;AAAA,IACtC;AAAA,EAAA,CACD;AAED,SAAO,iBAAiB;AAC1B;"}